---
title: 변수
description: 자바스크립트의 변수
date: 2024-01-12 22:45:59
tag: javascript
---

## 변수는 왜 필요할까

### 변수를 통해 메모리에 저장된 값에 접근

![변수1](/images/posts/js-variable/1.png)

컴퓨터는 메모리에 데이터를 저장하고, 메모리는 수많은 메모리 셸들로 이루어져있습니다.

<br />

하나의 메모리 셸에는 1바이트(8비트)의 데이터를 저장할 수 있는데, 이 때 데이터는 모두 2진수로 저장됩니다.
컴퓨터는 메모리 셸 단위로, 즉 1바이트 단위로 데이터를 저장하거나 읽습니다.

<br />

각 메모리 셸은 고유한 메모리 주소를 가집니다.
컴퓨터는 메모리 주소를 통해 데이터가 저장된 위치를 찾아서, 데이터에 접근할 수 있습니다.

<br />

변수를 사용하지 않더라도 메모리 주소가 있으면 메모리에 저장된 데이터에 접근할 수 있습니다.

하지만

1. 자바스크립트가 직접적인 메모리 제어를 허용하지 않고

2. 코드가 실행될 때마다 메모리 상황이 변하여 메모리 주소가 변경되기 때문에

개발자는 메모리 주소를 통해 값에 직접 접근할 수 없습니다.

<br />

그래서 변수가 필요합니다. 변수는 **값이 저장된 메모리의 위치를 가리키는 상징적인 이름**입니다.

메모리에 값을 저장하고, 변수를 가지고 그 값을 참조함으로써 값에 안전하게 접근할 수 있습니다.

포인트는 변수 ≠ 값이고, **변수 = 값이 저장된 메모리 주소를 참조한다**는 점입니다.

> 할당: 변수에 값을 저장하는 것
>
> 참조: 변수에 저장된 값을 읽어들이는 것

## 식별자

### 식별자는 어떤 값을 식별할 수 있는 고유한 이름

식별자는 값이 아니라 **메모리 주소를 기억**하고 있습니다.
식별자는 기억하고 있는 메모리 주소를 통해 메모리 공간에 저장된 값에 접근할 수 있습니다.

<br />

메모리 상에 존재하는 값을 식별할 수 있는 이름을 모두 식별자라고 부릅니다.
그렇기 때문에 변수도 식별자이고, 변수 외에 클래스, 함수 등도 식별자입니다.

## 변수 선언

### 변수를 선언하고 초기화

변수 선언은 값을 저장하기 위한 준비 단계입니다.
값을 저장할 메모리 공간을 확보하고, 메모리 주소를 변수명과 연결합니다.

<br />

자바스크립트에서는 `var`, `const`, `let` 키워드를 사용해서 변수를 선언합니다.
변수 선언 키워드를 마주치면 자바스크립트 엔진은 2단계를 거쳐 변수를 선언합니다.

1. 선언 단계: 변수 이름을 실행 컨텍스트에 등록합니다. 자바스크립트 엔진에게 변수의 존재를 알리는 과정입니다.

2. 초기화 단계: 메모리 공간을 확보하고 암묵적으로 `undefined`를 할당합니다.
   확보된 메모리 공간에 이전 값이 남아있을 수 있기 때문에 초기화 단계가 필요합니다.
   초기화 단계가 없으면 쓰레기 값을 참조할 수도 있습니다.

## 변수 선언의 실행 시점과 변수 호이스팅

### 변수 선언문은 런타임(코드 실행) 전에 먼저 실행

```js
console.log(test) // undefined

var test
```

자바스크립트는 인터프리터 언어이기 때문에 코드가 위에서부터 한줄씩 차례대로 실행됩니다.
console.log(test)가 실행될 시점은 test 변수가 선언되지 않을 시점이기에 에러가 날 것 같지만 undefined가 출력됩니다.

<br />

자바스크립트 엔진은 **코드 평가 -> 코드 실행** 순으로 런타임 이전에 코드 평가를 합니다.
코드 평가 과정에서 모든 선언문이 먼저 실행되기 때문에 코드 실행 전에 모든 식별자(변수, 함수 등)는 선언된 상태입니다.

<br />

그래서 **모든 식별자는 호이스팅된다**고 합니다.
호이스팅은 변수 선언문이 코드의 최상단으로 끌어 올려진 것처럼 동작하는 것을 의미합니다.
호이스팅으로 인해 변수는 코드의 어느 위치에 있든지 참조가 가능합니다.

## 값의 할당

### 런타임에 실행

```js
console.log(test) // undefined

var test = 100

console.log(test) // 100
```

선언과 할당을 하나의 문으로 단축해도 자바스크립트 엔진은 변수 선언 / 값의 할당 2개의 문으로 나누어 각각 실행합니다.
포인트는 **변수 선언 시점과 값 할당 시점**이 다르다는 점입니다. 변수 선언은 런타임 이전에, 값의 할당은 런타임에 실행됩니다.

### 초기화된 공간이 아니라 새로운 메모리 공간에 할당 값 저장

변수에 값을 할당할 때는 초기화된 undefined가 저장된 공간을 찾아서 그 안의 값을 할당 값으로 바꾸지 않습니다.
undefined가 저장된 공간은 놔두고 **새로운 메모리 공간에 할당 값을 저장하고, 새로운 메모리 주소를 변수명에 맵핑**합니다.

undefined로 초기화된 주소는 더 이상 참조되지 않기 때문에 이후 가비지 콜렉터에 의해 자동으로 해제됩니다.

## 값의 재할당

### var, let: 재할당 가능 / const: 재할당 불가능

```js
var test = 100
test = 200 // 200

const test = 100
test = 200 // TypeError
```

재할당은 이미 값이 할당된 변수에 새로운 값을 다시 할당하는 것을 의미합니다.
재할당 가능 여부는 어떤 키워드로 변수를 선언했는지에 따라 다릅니다.

|        | var  | const  | let  |
| :----: | :--: | :----: | :--: |
| 재할당 | 가능 | 불가능 | 가능 |

### 이전 값을 변경X, 새로운 메모리 공간에 저장

초기화 단계 이후 할당과 마찬가지로, 이전 값이 저장되어 있던 메모리 공간을 놔두고 새로운 메모리 공간에 할당 값을 저장합니다.

<br />

test에 100이 저장되어 있을 때 메모리 주소가 0x00000000였다면 200이 재할당된 변수가 가리키는 메모리 주소는 0x0660F913으로 다릅니다.
0x00000000 위치의 메모리는 더 이상 어떤 식별자와도 연결되어 있지 않으므로 가바지 콜렉터에 메모리에서 자동 해제 됩니다.
가비지 콜렉터가 언제 실행될지는 예측할 수 없고, 자바스크립트 엔진이 필요할 때 주기적으로 메모리를 정리합니다.
이를 통해 메모리 누수를 방지합니다.
